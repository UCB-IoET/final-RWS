from operator import *
debug = False
class void:
    def __repr__(self):
        return "<void>"

void = void()

nodes = {}
wireV = {} # wire values
wireS = {} # wire subscriptions
ready_q = []
ready = set()
_ast_docs = []
_func_docs = []
_node_switch_table = {}
_func_switch_table = {}

def node(name, fields, notes=None):
    def decorator(fn):
        _node_switch_table[name] = fn
    _ast_docs.append({'type': name,
                      'fields':fields,
                      'notes':notes})
    return decorator

def function(name, args, returns=None, notes=None):
    def decorator(fn):
        _func_switch_table[name] = fn
    _func_docs.append({'name': name,
                       'args': args,
                       'returns': returns,
                       'notes': notes})
    return decorator

@node('program',
      {'initial': 'list of node IDs that must be executed first',
       # or should this be a uuid? or should this be generated by the interpreter?
       'id': 'a unique id used to reference this running process',
       'wires': 'a list of all wire names',
       'connections': 'a dict mapping wires to list of receiving nodes',
       'nodes' :'a dict mapping IDs to nodes'})
def _(ast):
    run_program(ast)
def run_program(ast):
    print "run_program()"
    global nodes, wireV, wireS, ready, ready_q
    nodes = ast['nodes']
    wireS = ast['connections']
    wireV = {str(name) : void for name in range(len(wireS))}
    ready_q = ast.get('initial',[])
    ready = set(ready_q)
    while ready_q:
        node = ready_q.pop(0)
        ready.remove(node)
        run_id(node)
        print 'executing'

@node('literal',
      {'val': 'a literal number or string',
       'outputs': 'output wire'})
def _(ast):
    if debug: print('literal: {}'.format(ast['val']))
    set_and_signal(ast['outputs'][0], ast['val'])

@node('binop',
      {'op' : 'the operation, +, *, ==, >, ...',
       'inputs': 'a wire for the left hand side input',
       'inputs': 'a wire for the right hand side input',
       'outputs': 'output wire'})
def binop(ast):
    if debug: print "binop: {}({},{})".format(ast['op'], wire_get(ast['left']), wire_get(ast['right']))
    if wire_get(ast['left']) is void or wire_get(ast['right']) is void:
        print("some node wires not ready yet")
        return
    result = binop_map[ast['op']](wire_get(ast['left']), wire_get(ast['right']))
    set_and_signal(ast['out'], result)

binop_map = {'+' : add, '-' : sub, '*' : mul,'/' : truediv,
             '==': eq, '>': gt, '<': lt,'!=': ne}

@node('if',
      {'cond': 'condition',
       'true': "run when 'cond' is True'",
       'false': "run when 'cond' is False'"})
def _(ast):
    if debug:
        print "if: {} -> {}, {}".format(ast['cond'], ast['true'], ast['false'])
    cond = wire_get(ast['cond'])
    true, false = ('true', 'false') if cond else ('false', 'true')
    wire_set(ast[false], False)
    set_and_signal(ast[true], cond)


@node('call',
      {'name': 'name of built-in procedure to call',
       'inputs': 'the parameters - a list of input wires',
       'outputs': 'output wire for return value'})
def _(ast):
    if debug: print "call: {}{}".format(ast['name'], str(ast['input'][0]))
    fn = _func_switch_table[ast['name']]
    if not fn:
        error("call -- procedure '{}' was not found".format(ast['name']))
    ret = fn(*[wire_get(x) for x in ast['inputs']])
    out = ast.get('outputs')
    if out:
        set_and_signal(out, ret)


################################################################################
@function('print',
          {'inputs': 'a value to print'})
def _(input):
    print(input)
    return input

################################################################################

def run(ast):
    fn = _node_switch_table.get(ast.get('type'))
    if fn:
        fn(ast)
    else:
        print "Error: unknown node {}".format(ast)

def run_id(x):
    #print "nodes = {}".format(nodes)
    node = nodes.get(x)
    return node and run(node)


def subscribe(wire, node):
    s = wireS[wire]
    if not s:
        wireS[wire] = s = []
    s.append(node)

def signal(wire):
    global ready
    assert_exists('signal', wire)
    nodes = wireS.get(wire)
    if nodes:
        new = set(nodes).difference(ready)
        ready = ready.union(new)
        ready_q.extend(list(new))

def wire_set(wire, val):
    wireV[wire] = val

def set_and_signal(wire, val):
    wire_set(wire, val)
    signal(wire)

def wire_get(wire):
    assert_exists('wire_get', wire)
    return wireV[wire]

def set_ready(node_id):
    if node_id not in ready:
        ready.add(node_id)
        ready_q.append(node_id)

def assert_exists(fn, wire):
    if wire not in wireV:
        error("{} -- var '{}' not found".format(fn, wire))

def gen_doc():
    print "TODO"

def error(msg):
    print "Error: {}".format(msg)
    exit(1)
